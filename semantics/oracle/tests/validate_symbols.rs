use better_api_syntax::{parse, tokenize};
use indoc::indoc;

use crate::Oracle;

#[test]
fn valid_type_defs() {
    let text = indoc! {r#"
        type Foo: string
        type Bar: i32
        type Baz: Bar
        type Asdf: None
    "#};

    let mut diagnostics = vec![];
    let tokens = tokenize(text, &mut diagnostics);
    let res = parse(tokens);

    let mut oracle = Oracle::new_raw(&res.root);
    oracle.validate_symbols();

    assert!(oracle.reports().is_empty());

    let mut names: Vec<_> = oracle
        .symbol_map
        .keys()
        .map(|id| oracle.strings.resolve(*id))
        .collect();
    names.sort();
    assert_eq!(names, vec!["Asdf", "Bar", "Baz", "Foo"])
}

#[test]
fn redefine_type_def() {
    let text = indoc! {r#"
        type Foo: string
        type Foo: i32
    "#};

    let mut diagnostics = vec![];
    let tokens = tokenize(text, &mut diagnostics);
    let res = parse(tokens);

    let mut oracle = Oracle::new_raw(&res.root);
    oracle.validate_symbols();

    insta::assert_debug_snapshot!(oracle.reports());
}

#[test]
fn valid_cycles() {
    let text = indoc! {r#"
        type Foo: [Foo]
        type Bar: Bar?

        type Rec: rec {
            rec: Rec?
            name: string
            foo: Foo
        }

        type Union: union("type") {
            rec: Rec
        }

        type Response: resp {
            body: Union
        }
    "#};

    let mut diagnostics = vec![];
    let tokens = tokenize(text, &mut diagnostics);
    let res = parse(tokens);

    let mut oracle = Oracle::new_raw(&res.root);
    oracle.validate_symbols();

    assert!(oracle.reports().is_empty());

    let mut names: Vec<_> = oracle
        .symbol_map
        .keys()
        .map(|id| oracle.strings.resolve(*id))
        .collect();
    names.sort();
    assert_eq!(names, vec!["Bar", "Foo", "Rec", "Response", "Union"])
}

#[test]
fn invalid_cycles() {
    let text = indoc! {r#"
        type Foo: rec {
            bar: Bar
        }

        type Bar: union("type") {
            baz: Baz
        }

        type Baz: FooBar

        type FooBar: Foo

        type IgnoredEnum: enum(string) {
            "foo"
        }

        type Resp: resp {
            headers: Foo
        }
    "#};

    let mut diagnostics = vec![];
    let tokens = tokenize(text, &mut diagnostics);
    let res = parse(tokens);

    let mut oracle = Oracle::new_raw(&res.root);
    oracle.validate_symbols();

    // Reports are generated by iterating a HashMap. We sort it to stabilize
    // the order for snapshot purposes.
    oracle.reports.sort_by(|a, b| a.title.cmp(&b.title));
    insta::assert_debug_snapshot!(oracle.reports);

    let mut names: Vec<_> = oracle
        .symbol_map
        .keys()
        .map(|id| oracle.strings.resolve(*id))
        .collect();
    names.sort();
    assert_eq!(
        names,
        vec!["Bar", "Baz", "Foo", "FooBar", "IgnoredEnum", "Resp"]
    )
}
