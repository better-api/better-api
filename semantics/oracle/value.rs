use std::borrow::Cow;

use better_api_diagnostic::{Label, Report, Span};
use better_api_syntax::ast;
use better_api_syntax::ast::AstNode;
use string_interner::DefaultStringInterner;

use crate::text::{parse_string, validate_name};
use crate::value::{ArrayBuilder, ObjectBuilder, PrimitiveValue, ValueId};
use crate::{Element, SourceMap, StringId};

use super::Oracle;

/// Represents object field with interned name.
#[derive(Clone)]
struct InternedField {
    name: StringId,
    field: ast::ObjectField,
}

impl<'a> Oracle<'a> {
    /// Lower syntactical value [`ast::Value`] and store it in arena and source map mappings.
    pub(crate) fn lower_value(&mut self, value: &ast::Value) -> ValueId {
        let id = match ParsedValue::new(value, &mut self.reports, &mut self.strings) {
            ParsedValue::Primitive(primitive) => self.values.add_primitive(primitive),
            ParsedValue::Object(obj) => {
                let fields = parse_object_fields(obj, &mut self.reports, &mut self.strings);
                let builder = self.values.start_object();
                insert_object_fields(
                    fields,
                    builder,
                    &mut self.source_map,
                    &mut self.reports,
                    &mut self.strings,
                )
            }
            ParsedValue::Array(arr) => {
                let builder = self.values.start_array();
                insert_array_values(
                    arr.values(),
                    builder,
                    &mut self.source_map,
                    &mut self.reports,
                    &mut self.strings,
                )
            }
        };

        self.source_map.insert(value, Element::Value(id));
        id
    }
}

/// Helper type for handling primitive values, objects and arrays separately.
enum ParsedValue<'a> {
    Primitive(PrimitiveValue),
    Object(&'a ast::Object),
    Array(&'a ast::Array),
}

impl<'a> ParsedValue<'a> {
    /// Create a new [`ParsedValue`] from [`ast::Value`].
    ///
    /// Handling most values is done in a trivial way. Strings are a special case.
    /// They are parsed with [`parse_string`] and interned.
    fn new(
        value: &'a ast::Value,
        reports: &mut Vec<Report>,
        strings: &mut DefaultStringInterner,
    ) -> Self {
        match value {
            ast::Value::String(string) => {
                let token = string.string();
                let parsed_str = parse_string(&token, reports);
                let str_id = strings.get_or_intern(&parsed_str);

                Self::Primitive(PrimitiveValue::String(str_id))
            }
            ast::Value::Integer(integer) => {
                Self::Primitive(PrimitiveValue::Integer(integer.integer()))
            }
            ast::Value::Float(float) => Self::Primitive(PrimitiveValue::Float(float.float())),
            ast::Value::Bool(bool) => Self::Primitive(PrimitiveValue::Bool(bool.bool())),
            ast::Value::Object(obj) => Self::Object(obj),
            ast::Value::Array(arr) => Self::Array(arr),
        }
    }
}

/// Collects object fields into a vector.
///
/// Only valid fields are collected. Field is valid if it has a valid name and a value.
/// Names are interned.
///
/// Returned vector is sorted by name, which stabilizes the fields. This is useful for
/// type checking.
///
/// Function also validates that all fields in the object have unique name and reports errors
/// if they aren't.
fn parse_object_fields(
    object: &ast::Object,
    reports: &mut Vec<Report>,
    strings: &mut DefaultStringInterner,
) -> Vec<InternedField> {
    let mut fields: Vec<_> = object
        .fields()
        .filter_map(|f| {
            f.value()?;

            let name = f.name().map(|n| n.token())?;
            let name_str: Cow<_> = match &name {
                ast::NameToken::Identifier(ident) => ident.text().into(),
                ast::NameToken::String(string) => parse_string(string, reports),
            };

            if let Err(report) = validate_name(&name_str, name.text_range()) {
                reports.push(report);
                return None;
            }

            let name_id = strings.get_or_intern(name_str);
            Some(InternedField {
                name: name_id,
                field: f,
            })
        })
        .collect();

    fields.sort_by_key(|f| f.name);
    check_object_fields_unique(&fields, reports, strings);

    fields
}

/// Inserts object fields generated by [`parse_object_fields`] into a provided [`ObjectBuilder`].
fn insert_object_fields(
    fields: Vec<InternedField>,
    mut builder: ObjectBuilder,
    source_map: &mut SourceMap,
    reports: &mut Vec<Report>,
    strings: &mut DefaultStringInterner,
) -> ValueId {
    for field in fields {
        let value = field
            .field
            .value()
            .expect("inserted field should have a value");

        let field_id = match ParsedValue::new(&value, reports, strings) {
            ParsedValue::Primitive(primitive) => builder.add_primitive(field.name, primitive),
            ParsedValue::Object(obj) => {
                let fields = parse_object_fields(obj, reports, strings);
                let (child_builder, field_id) = builder.start_object(field.name);

                insert_object_fields(fields, child_builder, source_map, reports, strings);

                field_id
            }
            ParsedValue::Array(arr) => {
                let (child_builder, field_id) = builder.start_array(field.name);

                insert_array_values(arr.values(), child_builder, source_map, reports, strings);

                field_id
            }
        };

        source_map.insert(&value, Element::Value(field_id.value_id()));
        source_map.insert(&field.field, Element::ObjectField(field_id));
    }

    builder.finish()
}

/// Inserts array values into a provided [`ArrayBuilder`].
pub(crate) fn insert_array_values(
    values: impl Iterator<Item = ast::Value>,
    mut builder: ArrayBuilder,
    source_map: &mut SourceMap,
    reports: &mut Vec<Report>,
    strings: &mut DefaultStringInterner,
) -> ValueId {
    for value in values {
        let value_id = match ParsedValue::new(&value, reports, strings) {
            ParsedValue::Primitive(primitive) => builder.add_primitive(primitive),
            ParsedValue::Object(obj) => {
                let fields = parse_object_fields(obj, reports, strings);
                let child_builder = builder.start_object();

                insert_object_fields(fields, child_builder, source_map, reports, strings)
            }
            ParsedValue::Array(arr) => {
                let child_builder = builder.start_array();
                insert_array_values(arr.values(), child_builder, source_map, reports, strings)
            }
        };

        source_map.insert(&value, Element::Value(value_id));
    }

    builder.finish()
}

/// Check that names of object fields are unique.
/// Fields are expected to be sorted by name.
fn check_object_fields_unique(
    fields: &[InternedField],
    reports: &mut Vec<Report>,
    strings: &DefaultStringInterner,
) {
    if fields.is_empty() {
        return;
    }

    for idx in 0..(fields.len() - 1) {
        if fields[idx].name != fields[idx + 1].name {
            continue;
        }

        let name = strings
            .resolve(fields[idx].name)
            .expect("interned string should be present in interner");

        let range = fields[idx + 1]
            .field
            .name()
            .expect("collected object field should have a name")
            .syntax()
            .text_range();

        reports.push(
            Report::error(format!("repeated object key `{name}`")).with_label(Label::new(
                "repeated object key".to_string(),
                Span::new(range.start().into(), range.end().into()),
            )),
        );
    }
}
