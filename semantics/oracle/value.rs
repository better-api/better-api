use better_api_diagnostic::{Label, Report};
use better_api_syntax::ast;
use better_api_syntax::ast::AstNode;

use crate::spec::value::{ArrayBuilder, ObjectBuilder, PrimitiveValue, ValueArena, ValueId};
use crate::string::{StringId, StringInterner};
use crate::text::{lower_name, parse_string};

use super::Oracle;

/// Represents object field with interned name.
#[derive(Clone)]
struct InternedField {
    name: StringId,
    field: ast::ObjectField,
}

impl<'a> Oracle<'a> {
    /// Sugar method for lowering a value. Calls [`lower_value`].
    pub(crate) fn lower_value(&mut self, value: &ast::Value) -> ValueId {
        lower_value(
            &mut self.values,
            &mut self.strings,
            &mut self.reports,
            value,
        )
    }
}

/// Lower syntactical value [`ast::Value`] and store it in arena and source map mappings.
pub(crate) fn lower_value(
    values: &mut ValueArena,
    strings: &mut StringInterner,
    reports: &mut Vec<Report>,
    value: &ast::Value,
) -> ValueId {
    match ParsedValue::new(value, reports, strings) {
        ParsedValue::Primitive(primitive) => values.add_primitive(primitive),
        ParsedValue::Object(obj) => {
            let fields = parse_object_fields(obj, reports, strings);
            let builder = values.start_object();
            insert_object_fields(fields, builder, reports, strings)
        }
        ParsedValue::Array(arr) => {
            let builder = values.start_array();
            insert_array_values(arr.values(), builder, reports, strings)
        }
    }
}

/// Helper type for handling primitive values, objects and arrays separately.
enum ParsedValue<'a> {
    Primitive(PrimitiveValue),
    Object(&'a ast::Object),
    Array(&'a ast::Array),
}

impl<'a> ParsedValue<'a> {
    /// Create a new [`ParsedValue`] from [`ast::Value`].
    ///
    /// Handling most values is done in a trivial way. Strings are a special case.
    /// They are parsed with [`parse_string`] and interned.
    fn new(value: &'a ast::Value, reports: &mut Vec<Report>, strings: &mut StringInterner) -> Self {
        match value {
            ast::Value::String(string) => {
                let token = string.string();
                let parsed_str = parse_string(&token, reports);
                let str_id = strings.get_or_intern(&parsed_str);

                Self::Primitive(PrimitiveValue::String(str_id))
            }
            ast::Value::Integer(integer) => {
                Self::Primitive(PrimitiveValue::Integer(integer.integer()))
            }
            ast::Value::Float(float) => Self::Primitive(PrimitiveValue::Float(float.float())),
            ast::Value::Bool(bool) => Self::Primitive(PrimitiveValue::Bool(bool.bool())),
            ast::Value::Object(obj) => Self::Object(obj),
            ast::Value::Array(arr) => Self::Array(arr),
        }
    }
}

/// Collects object fields into a vector.
///
/// Only valid fields are collected. Field is valid if it has a valid name and a value.
/// Names are interned.
///
/// Returned vector is sorted by name, which stabilizes the fields. This is useful for
/// type checking.
///
/// Function also validates that all fields in the object have unique name and reports errors
/// if they aren't.
fn parse_object_fields(
    object: &ast::Object,
    reports: &mut Vec<Report>,
    strings: &mut StringInterner,
) -> Vec<InternedField> {
    let mut fields: Vec<_> = object
        .fields()
        .filter_map(|f| {
            // Missing name or value is reported by parser.
            f.value()?;

            let name = f.name().and_then(|n| lower_name(&n, strings, reports))?;
            Some(InternedField { name, field: f })
        })
        .collect();

    fields.sort_by_key(|f| f.name);
    check_object_fields_unique(&fields, reports, strings);

    fields
}

/// Inserts object fields generated by [`parse_object_fields`] into a provided [`ObjectBuilder`].
fn insert_object_fields(
    fields: Vec<InternedField>,
    mut builder: ObjectBuilder,
    reports: &mut Vec<Report>,
    strings: &mut StringInterner,
) -> ValueId {
    for field in fields {
        let value = field
            .field
            .value()
            .expect("inserted field should have a value");

        match ParsedValue::new(&value, reports, strings) {
            ParsedValue::Primitive(primitive) => {
                builder.add_primitive(field.name, primitive);
            }
            ParsedValue::Object(obj) => {
                let fields = parse_object_fields(obj, reports, strings);
                let (child_builder, _) = builder.start_object(field.name);
                insert_object_fields(fields, child_builder, reports, strings);
            }
            ParsedValue::Array(arr) => {
                let (child_builder, _) = builder.start_array(field.name);
                insert_array_values(arr.values(), child_builder, reports, strings);
            }
        };
    }

    builder.finish()
}

/// Inserts array values into a provided [`ArrayBuilder`].
pub(crate) fn insert_array_values(
    values: impl Iterator<Item = ast::Value>,
    mut builder: ArrayBuilder,
    reports: &mut Vec<Report>,
    strings: &mut StringInterner,
) -> ValueId {
    for value in values {
        match ParsedValue::new(&value, reports, strings) {
            ParsedValue::Primitive(primitive) => {
                builder.add_primitive(primitive);
            }
            ParsedValue::Object(obj) => {
                let fields = parse_object_fields(obj, reports, strings);
                let child_builder = builder.start_object();
                insert_object_fields(fields, child_builder, reports, strings);
            }
            ParsedValue::Array(arr) => {
                let child_builder = builder.start_array();
                insert_array_values(arr.values(), child_builder, reports, strings);
            }
        };
    }

    builder.finish()
}

/// Check that names of object fields are unique.
/// Fields are expected to be sorted by name.
fn check_object_fields_unique(
    fields: &[InternedField],
    reports: &mut Vec<Report>,
    strings: &StringInterner,
) {
    if fields.is_empty() {
        return;
    }

    for idx in 0..(fields.len() - 1) {
        if fields[idx].name != fields[idx + 1].name {
            continue;
        }

        let name = strings.resolve(fields[idx].name);

        let range = fields[idx + 1]
            .field
            .name()
            .expect("collected object field should have a name")
            .syntax()
            .text_range();

        reports.push(
            Report::error(format!("repeated object key `{name}`")).add_label(Label::primary(
                "repeated object key".to_string(),
                range.into(),
            )),
        );
    }
}
