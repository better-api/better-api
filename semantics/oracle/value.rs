use std::borrow::Cow;

use better_api_diagnostic::{Label, Report, Span};
use better_api_syntax::ast;
use better_api_syntax::ast::AstNode;
use string_interner::DefaultStringInterner;

use crate::text::{parse_string, validate_name};
use crate::value::{ArrayBuilder, ObjectBuilder, PrimitiveValue, ValueId};
use crate::{Element, SourceMap, StringId};

use super::Oracle;

/// Represents object field with interned name.
#[derive(Clone)]
struct InternedField {
    name: StringId,
    field: ast::ObjectField,
}

impl<'a> Oracle<'a> {
    /// Parse syntactical value [`ast::Value`] and store it in arena and source map mappings.
    pub(crate) fn parse_value(&mut self, value: &ast::Value) -> ValueId {
        let id = match ParsedValue::new(value, &mut self.reports, &mut self.strings) {
            ParsedValue::Primitive(primitive) => self.values.add_primitive(primitive),
            ParsedValue::Object(obj) => {
                let fields = parse_object_fields(obj, &mut self.reports, &mut self.strings);
                let builder = self.values.start_object();
                insert_object_fields(
                    fields,
                    builder,
                    &mut self.source_map,
                    &mut self.reports,
                    &mut self.strings,
                )
            }
            ParsedValue::Array(arr) => {
                let builder = self.values.start_array();
                insert_array_values(
                    arr.values(),
                    builder,
                    &mut self.source_map,
                    &mut self.reports,
                    &mut self.strings,
                )
            }
        };

        self.source_map.insert(value, Element::Value(id));
        id
    }
}

/// Helper type for handling primitive values, objects and arrays separately.
enum ParsedValue<'a> {
    Primitive(PrimitiveValue),
    Object(&'a ast::Object),
    Array(&'a ast::Array),
}

impl<'a> ParsedValue<'a> {
    /// Create a new [`ParsedValue`] from [`ast::Value`].
    ///
    /// Handling most values is done in a trivial way. Strings are a special case.
    /// They are parsed with [`parse_string`] and interned.
    fn new(
        value: &'a ast::Value,
        reports: &mut Vec<Report>,
        strings: &mut DefaultStringInterner,
    ) -> Self {
        match value {
            ast::Value::String(string) => {
                let token = string.string();
                let parsed_str = parse_string(&token, reports);
                let str_id = strings.get_or_intern(&parsed_str);

                Self::Primitive(PrimitiveValue::String(str_id))
            }
            ast::Value::Integer(integer) => {
                Self::Primitive(PrimitiveValue::Integer(integer.integer()))
            }
            ast::Value::Float(float) => Self::Primitive(PrimitiveValue::Float(float.float())),
            ast::Value::Bool(bool) => Self::Primitive(PrimitiveValue::Bool(bool.bool())),
            ast::Value::Object(obj) => Self::Object(obj),
            ast::Value::Array(arr) => Self::Array(arr),
        }
    }
}

/// Collects object fields into a vector.
///
/// Only valid fields are collected. Field is valid if it has a valid name and a value.
/// Names are interned.
///
/// Returned vector is sorted by name, which stabilizes the fields. This is useful for
/// type checking.
///
/// Function also validates that all fields in the object have unique name and reports errors
/// if they aren't.
fn parse_object_fields(
    object: &ast::Object,
    reports: &mut Vec<Report>,
    strings: &mut DefaultStringInterner,
) -> Vec<InternedField> {
    let mut fields: Vec<_> = object
        .fields()
        .filter_map(|f| {
            f.value()?;

            let name = f.name().map(|n| n.token())?;
            let name_str: Cow<_> = match &name {
                ast::NameToken::Identifier(ident) => ident.text().into(),
                ast::NameToken::String(string) => parse_string(string, reports),
            };

            if let Err(report) = validate_name(&name_str, name.text_range()) {
                reports.push(report);
                return None;
            }

            let name_id = strings.get_or_intern(name_str);
            Some(InternedField {
                name: name_id,
                field: f,
            })
        })
        .collect();

    fields.sort_by_key(|f| f.name);
    check_object_fields_unique(&fields, reports, strings);

    fields
}

/// Inserts object fields generated by [`parse_object_fields`] into a provided [`ObjectBuilder`].
fn insert_object_fields(
    fields: Vec<InternedField>,
    mut builder: ObjectBuilder,
    source_map: &mut SourceMap,
    reports: &mut Vec<Report>,
    strings: &mut DefaultStringInterner,
) -> ValueId {
    for field in fields {
        let value = field
            .field
            .value()
            .expect("inserted field should have a value");

        let field_id = match ParsedValue::new(&value, reports, strings) {
            ParsedValue::Primitive(primitive) => builder.add_primitive(field.name, primitive),
            ParsedValue::Object(obj) => {
                let fields = parse_object_fields(obj, reports, strings);
                let (child_builder, field_id) = builder.start_object(field.name);

                insert_object_fields(fields, child_builder, source_map, reports, strings);

                field_id
            }
            ParsedValue::Array(arr) => {
                let (child_builder, field_id) = builder.start_array(field.name);

                insert_array_values(arr.values(), child_builder, source_map, reports, strings);

                field_id
            }
        };

        source_map.insert(&value, Element::Value(field_id.value_id()));
        source_map.insert(&field.field, Element::ObjectField(field_id));
    }

    builder.finish()
}

/// Inserts array values into a provided [`ArrayBuilder`].
pub(crate) fn insert_array_values(
    values: impl Iterator<Item = ast::Value>,
    mut builder: ArrayBuilder,
    source_map: &mut SourceMap,
    reports: &mut Vec<Report>,
    strings: &mut DefaultStringInterner,
) -> ValueId {
    for value in values {
        let value_id = match ParsedValue::new(&value, reports, strings) {
            ParsedValue::Primitive(primitive) => builder.add_primitive(primitive),
            ParsedValue::Object(obj) => {
                let fields = parse_object_fields(obj, reports, strings);
                let child_builder = builder.start_object();

                insert_object_fields(fields, child_builder, source_map, reports, strings)
            }
            ParsedValue::Array(arr) => {
                let child_builder = builder.start_array();
                insert_array_values(arr.values(), child_builder, source_map, reports, strings)
            }
        };

        source_map.insert(&value, Element::Value(value_id));
    }

    builder.finish()
}

/// Check that names of object fields are unique.
/// Fields are expected to be sorted by name.
fn check_object_fields_unique(
    fields: &[InternedField],
    reports: &mut Vec<Report>,
    strings: &DefaultStringInterner,
) {
    if fields.is_empty() {
        return;
    }

    for idx in 0..(fields.len() - 1) {
        if fields[idx].name != fields[idx + 1].name {
            continue;
        }

        let name = strings
            .resolve(fields[idx].name)
            .expect("interned string should be present in interner");

        let range = fields[idx + 1]
            .field
            .name()
            .expect("collected object field should have a name")
            .syntax()
            .text_range();

        reports.push(
            Report::error(format!("repeated object key `{name}`")).with_label(Label::new(
                "repeated object key".to_string(),
                Span::new(range.start().into(), range.end().into()),
            )),
        );
    }
}

#[cfg(test)]
mod test {
    use better_api_diagnostic::{Label, Report, Span};
    use better_api_syntax::{parse, tokenize};
    use indoc::indoc;

    use crate::value::Value;
    use crate::{Element, Oracle};

    #[test]
    fn parse_primitive_integer() {
        let text = indoc! {r#"
            name: 10
        "#};

        let mut diagnostics = vec![];
        let tokens = tokenize(text, &mut diagnostics);
        let res = parse(tokens);

        let mut oracle = Oracle::new_raw(&res.root);

        let value = res.root.api_names().next().unwrap().value().unwrap();
        let id = oracle.parse_value(&value);

        assert_eq!(oracle.reports(), vec![]);
        assert_eq!(oracle.values.get(id), Value::Integer(10));
        oracle.source_map.get_bck(&Element::Value(id));
    }

    #[test]
    fn parse_primitive_float() {
        let text = indoc! {r#"
            name: 4.20
        "#};

        let mut diagnostics = vec![];
        let tokens = tokenize(text, &mut diagnostics);
        let res = parse(tokens);

        let mut oracle = Oracle::new_raw(&res.root);

        let value = res.root.api_names().next().unwrap().value().unwrap();
        let id = oracle.parse_value(&value);

        assert_eq!(oracle.reports(), vec![]);
        assert_eq!(oracle.values.get(id), Value::Float(4.20));
        oracle.source_map.get_bck(&Element::Value(id));
    }

    #[test]
    fn parse_primitive_bool() {
        let text = indoc! {r#"
            name: true
            name: false
        "#};

        let mut diagnostics = vec![];
        let tokens = tokenize(text, &mut diagnostics);
        let res = parse(tokens);

        let mut oracle = Oracle::new_raw(&res.root);

        let mut api_names = res.root.api_names();

        let value1 = api_names.next().unwrap().value().unwrap();
        let id1 = oracle.parse_value(&value1);
        assert_eq!(oracle.values.get(id1), Value::Bool(true));
        oracle.source_map.get_bck(&Element::Value(id1));

        let value2 = api_names.next().unwrap().value().unwrap();
        let id2 = oracle.parse_value(&value2);
        assert_eq!(oracle.values.get(id2), Value::Bool(false));
        oracle.source_map.get_bck(&Element::Value(id2));

        assert_eq!(oracle.reports(), vec![]);
    }

    #[test]
    fn parse_primitive_string() {
        let text = indoc! {r#"
            name: "hello world"
        "#};

        let mut diagnostics = vec![];
        let tokens = tokenize(text, &mut diagnostics);
        let res = parse(tokens);

        let mut oracle = Oracle::new_raw(&res.root);

        let value = res.root.api_names().next().unwrap().value().unwrap();
        let id = oracle.parse_value(&value);

        assert_eq!(oracle.reports(), vec![]);

        match oracle.values.get(id) {
            Value::String(str_id) => {
                let resolved = oracle.strings.resolve(str_id).unwrap();
                assert_eq!(resolved, "hello world");
            }
            other => panic!("expected string value, got {other:?}"),
        }
        oracle.source_map.get_bck(&Element::Value(id));
    }

    #[test]
    fn parse_primitive_string_with_escapes() {
        let text = indoc! {r#"
            name: "hello\nworld\t\"\\"
        "#};

        let mut diagnostics = vec![];
        let tokens = tokenize(text, &mut diagnostics);
        let res = parse(tokens);

        let mut oracle = Oracle::new_raw(&res.root);

        let value = res.root.api_names().next().unwrap().value().unwrap();
        let id = oracle.parse_value(&value);

        assert_eq!(oracle.reports(), vec![]);
        match oracle.values.get(id) {
            Value::String(str_id) => {
                let resolved = oracle.strings.resolve(str_id).unwrap();
                assert_eq!(resolved, "hello\nworld\t\"\\");
            }
            other => panic!("expected string value, got {other:?}"),
        }
        oracle.source_map.get_bck(&Element::Value(id));
    }

    #[test]
    fn parse_array() {
        let text = indoc! {r#"
            name: [1, 2, 3]
        "#};

        let mut diagnostics = vec![];
        let tokens = tokenize(text, &mut diagnostics);
        let res = parse(tokens);

        let mut oracle = Oracle::new_raw(&res.root);

        let value = res.root.api_names().next().unwrap().value().unwrap();
        let id = oracle.parse_value(&value);

        assert_eq!(oracle.reports(), vec![]);

        let array = match oracle.values.get(id) {
            Value::Array(arr) => arr,
            other => panic!("expected array value, got {other:?}"),
        };

        let item_ids: Vec<_> = array.map(|it| it.id).collect();
        assert_eq!(
            item_ids
                .iter()
                .map(|&id| oracle.values.get(id))
                .collect::<Vec<_>>(),
            vec![Value::Integer(1), Value::Integer(2), Value::Integer(3),]
        );

        // Verify array and all items are in source map
        assert_eq!(oracle.source_map.fwd.len(), 4);
        assert_eq!(oracle.source_map.bck.len(), 4);
        oracle.source_map.get_bck(&Element::Value(id));
        for id in item_ids {
            oracle.source_map.get_bck(&Element::Value(id));
        }
    }

    #[test]
    fn parse_empty_array() {
        let text = indoc! {r#"
            name: []
        "#};

        let mut diagnostics = vec![];
        let tokens = tokenize(text, &mut diagnostics);
        let res = parse(tokens);

        let mut oracle = Oracle::new_raw(&res.root);

        let value = res.root.api_names().next().unwrap().value().unwrap();
        let id = oracle.parse_value(&value);

        assert_eq!(oracle.reports(), vec![]);
        match oracle.values.get(id) {
            Value::Array(arr) => assert_eq!(arr.count(), 0),
            other => panic!("expected array value, got {other:?}"),
        }

        assert_eq!(oracle.source_map.fwd.len(), 1);
        assert_eq!(oracle.source_map.bck.len(), 1);
        oracle.source_map.get_bck(&Element::Value(id));
    }

    #[test]
    fn parse_nested_array() {
        let text = indoc! {r#"
            name: [1, [2, 3], 4]
        "#};

        let mut diagnostics = vec![];
        let tokens = tokenize(text, &mut diagnostics);
        let res = parse(tokens);

        let mut oracle = Oracle::new_raw(&res.root);

        let value = res.root.api_names().next().unwrap().value().unwrap();
        let id = oracle.parse_value(&value);

        assert_eq!(oracle.reports(), vec![]);

        let outer = match oracle.values.get(id) {
            Value::Array(arr) => arr,
            other => panic!("expected array value, got {other:?}"),
        };
        oracle.source_map.get_bck(&Element::Value(id));

        let outer_items: Vec<_> = outer.map(|it| (it.id, it.value)).collect();
        assert_eq!(outer_items.len(), 3);
        assert_eq!(outer_items[0].1, Value::Integer(1));
        assert_eq!(outer_items[2].1, Value::Integer(4));

        // Verify all outer items are in source map
        for (item_id, _) in &outer_items {
            oracle.source_map.get_bck(&Element::Value(*item_id));
        }

        let inner = match &outer_items[1].1 {
            Value::Array(arr) => arr.clone(),
            other => panic!("expected array value, got {other:?}"),
        };

        let inner_items: Vec<_> = inner.map(|it| (it.id, it.value)).collect();
        assert_eq!(
            inner_items.iter().map(|(_, v)| v).collect::<Vec<_>>(),
            vec![&Value::Integer(2), &Value::Integer(3)]
        );

        // Verify all inner items are in source map
        for (item_id, _) in &inner_items {
            oracle.source_map.get_bck(&Element::Value(*item_id));
        }

        // Verify length of source map
        assert_eq!(oracle.source_map.fwd.len(), 6);
        assert_eq!(oracle.source_map.bck.len(), 6);
    }

    #[test]
    fn parse_object_empty() {
        let text = indoc! {r#"
            name: {}
        "#};

        let mut diagnostics = vec![];
        let tokens = tokenize(text, &mut diagnostics);
        let res = parse(tokens);

        let mut oracle = Oracle::new_raw(&res.root);

        let value = res.root.api_names().next().unwrap().value().unwrap();
        let id = oracle.parse_value(&value);

        assert_eq!(oracle.reports(), vec![]);
        match oracle.values.get(id) {
            Value::Object(obj) => {
                assert_eq!(obj.count(), 0);
            }
            other => panic!("expected object value, got {other:?}"),
        }
        oracle.source_map.get_bck(&Element::Value(id));
    }

    #[test]
    fn parse_object_simple() {
        // Test parsing of simple objects.
        // We have two objects that are the same, but with different ordering of fields.
        // This test also checks that ordering is the same, which means we have stable
        // ordering.
        let text = indoc! {r#"
            name: {
                foo: 10
                bar: "test"
            }

            name: {
                bar: "test"
                foo: 10
            }
        "#};

        let mut diagnostics = vec![];
        let tokens = tokenize(text, &mut diagnostics);
        let res = parse(tokens);

        let mut oracle = Oracle::new_raw(&res.root);

        assert_eq!(res.root.api_names().count(), 2);
        for name in res.root.api_names() {
            let id = oracle.parse_value(&name.value().unwrap());

            assert_eq!(oracle.reports(), vec![]);
            let obj = match oracle.values.get(id) {
                Value::Object(obj) => obj,
                other => panic!("expected object value, got {other:?}"),
            };
            oracle.source_map.get_bck(&Element::Value(id));

            let fields: Vec<_> = obj.collect();
            assert_eq!(fields.len(), 2);

            let names: Vec<_> = fields
                .iter()
                .map(|field| oracle.strings.resolve(field.name).unwrap())
                .collect();
            assert_eq!(names, vec!["foo", "bar"]);

            // Verify all fields and their values are in source map
            for field in &fields {
                oracle.source_map.get_bck(&Element::ObjectField(field.id));
                oracle
                    .source_map
                    .get_bck(&Element::Value(field.id.value_id()));
            }

            let values: Vec<_> = fields.into_iter().map(|field| field.value).collect();
            assert_eq!(values[0], Value::Integer(10));
            assert!(matches!(values[1], Value::String(_)));
        }

        // Verify source map is correct length
        assert_eq!(oracle.source_map.fwd.len(), 10);
        assert_eq!(oracle.source_map.bck.len(), 10);
    }

    #[test]
    fn parse_object_with_string_keys() {
        let text = indoc! {r#"
            name: {
                "foo-bar": 10
                "baz": 20
            }
        "#};

        let mut diagnostics = vec![];
        let tokens = tokenize(text, &mut diagnostics);
        let res = parse(tokens);

        let mut oracle = Oracle::new_raw(&res.root);

        let value = res.root.api_names().next().unwrap().value().unwrap();
        let id = oracle.parse_value(&value);

        assert_eq!(oracle.reports(), vec![]);
        let obj = match oracle.values.get(id) {
            Value::Object(obj) => obj,
            other => panic!("expected object value, got {other:?}"),
        };
        oracle.source_map.get_bck(&Element::Value(id));

        let fields: Vec<_> = obj.collect();
        assert_eq!(fields.len(), 2);

        let names: Vec<_> = fields
            .iter()
            .map(|field| oracle.strings.resolve(field.name).unwrap())
            .collect();
        assert_eq!(names, vec!["foo-bar", "baz"]);

        // Verify all fields and their values are in source map
        for field in &fields {
            oracle.source_map.get_bck(&Element::ObjectField(field.id));
            oracle
                .source_map
                .get_bck(&Element::Value(field.id.value_id()));
        }

        let values: Vec<_> = fields.into_iter().map(|field| field.value).collect();
        assert_eq!(values[0], Value::Integer(10));
        assert_eq!(values[1], Value::Integer(20));

        // Verify source map is correct length
        assert_eq!(oracle.source_map.fwd.len(), 5);
        assert_eq!(oracle.source_map.bck.len(), 5);
    }

    #[test]
    fn parse_object_missing_value() {
        let text = indoc! {r#"
            name: {
                foo:
                bar: 20
            }
        "#};

        let mut diagnostics = vec![];
        let tokens = tokenize(text, &mut diagnostics);
        let res = parse(tokens);

        let mut oracle = Oracle::new_raw(&res.root);

        let value = res.root.api_names().next().unwrap().value().unwrap();
        let id = oracle.parse_value(&value);
        assert_eq!(oracle.reports(), vec![]);

        // Field with missing value should be skipped
        let obj = match oracle.values.get(id) {
            Value::Object(obj) => obj,
            other => panic!("expected object value, got {other:?}"),
        };
        oracle.source_map.get_bck(&Element::Value(id));

        let fields: Vec<_> = obj.collect();
        assert_eq!(fields.len(), 1);

        let field_name = oracle.strings.resolve(fields[0].name).unwrap();
        assert_eq!(field_name, "bar");
        assert_eq!(fields[0].value, Value::Integer(20));

        oracle
            .source_map
            .get_bck(&Element::ObjectField(fields[0].id));
        oracle
            .source_map
            .get_bck(&Element::Value(fields[0].id.value_id()));

        // Verify source map is correct length
        assert_eq!(oracle.source_map.fwd.len(), 3);
        assert_eq!(oracle.source_map.bck.len(), 3);
    }

    #[test]
    fn parse_object_invalid_field_name() {
        let text = indoc! {r#"
            name: {
                "invalid name": 10
                valid: 20
            }
        "#};

        let mut diagnostics = vec![];
        let tokens = tokenize(text, &mut diagnostics);
        let res = parse(tokens);

        let mut oracle = Oracle::new_raw(&res.root);

        let value = res.root.api_names().next().unwrap().value().unwrap();
        let id = oracle.parse_value(&value);

        // Should have error for invalid name
        assert_eq!(
            oracle.reports(),
            vec![
                Report::error("invalid name".to_string())
                    .with_label(Label::new("invalid name".to_string(), Span::new(12, 26)))
                    .with_note(
                        "help: name can only contain alphanumeric characters, `_`, `-` and `.`. It also has to start with alphabetic character.".to_string()
                    )
            ]
        );

        // Only valid field should be present
        let obj = match oracle.values.get(id) {
            Value::Object(obj) => obj,
            other => panic!("expected object value, got {other:?}"),
        };
        oracle.source_map.get_bck(&Element::Value(id));

        let fields: Vec<_> = obj.collect();
        assert_eq!(fields.len(), 1);

        let field_name = oracle.strings.resolve(fields[0].name).unwrap();
        assert_eq!(field_name, "valid");
        assert_eq!(fields[0].value, Value::Integer(20));

        oracle
            .source_map
            .get_bck(&Element::ObjectField(fields[0].id));
        oracle
            .source_map
            .get_bck(&Element::Value(fields[0].id.value_id()));

        // Verify source map is correct length
        assert_eq!(oracle.source_map.fwd.len(), 3);
        assert_eq!(oracle.source_map.bck.len(), 3);
    }

    #[test]
    fn parse_object_duplicate_keys() {
        use better_api_diagnostic::{Label, Report, Span};

        let text = indoc! {r#"
            name: {
                foo: 10
                bar: 20
                foo: 10
            }
        "#};

        let mut diagnostics = vec![];
        let tokens = tokenize(text, &mut diagnostics);
        let res = parse(tokens);

        let mut oracle = Oracle::new_raw(&res.root);

        let value = res.root.api_names().next().unwrap().value().unwrap();
        let id = oracle.parse_value(&value);

        // Should have error for duplicate key
        assert_eq!(
            oracle.reports(),
            vec![
                Report::error("repeated object key `foo`".to_string()).with_label(Label::new(
                    "repeated object key".to_string(),
                    Span::new(36, 39)
                ))
            ]
        );

        // All fields should still be present in the arena
        let obj = match oracle.values.get(id) {
            Value::Object(obj) => obj,
            other => panic!("expected object value, got {other:?}"),
        };
        oracle.source_map.get_bck(&Element::Value(id));

        let fields: Vec<_> = obj.collect();
        assert_eq!(fields.len(), 3);

        let names: Vec<_> = fields
            .iter()
            .map(|field| oracle.strings.resolve(field.name).unwrap())
            .collect();
        assert_eq!(names, vec!["foo", "foo", "bar"]);

        // Verify all fields and their values are in source map
        for field in &fields {
            oracle.source_map.get_bck(&Element::ObjectField(field.id));
            oracle
                .source_map
                .get_bck(&Element::Value(field.id.value_id()));
        }

        let values: Vec<_> = fields.into_iter().map(|field| field.value).collect();
        assert_eq!(values[0], Value::Integer(10));
        assert_eq!(values[1], Value::Integer(10));
        assert_eq!(values[2], Value::Integer(20));

        // Verify source map is correct length
        assert_eq!(oracle.source_map.fwd.len(), 7);
        assert_eq!(oracle.source_map.bck.len(), 7);
    }

    #[test]
    fn parse_object_nested() {
        let text = indoc! {r#"
            name: {
                outer: {
                    inner: 42
                }
            }
        "#};

        let mut diagnostics = vec![];
        let tokens = tokenize(text, &mut diagnostics);
        let res = parse(tokens);

        let mut oracle = Oracle::new_raw(&res.root);

        let value = res.root.api_names().next().unwrap().value().unwrap();
        let id = oracle.parse_value(&value);

        assert_eq!(oracle.reports(), vec![]);

        let obj = match oracle.values.get(id) {
            Value::Object(obj) => obj,
            other => panic!("expected object value, got {other:?}"),
        };
        oracle.source_map.get_bck(&Element::Value(id));

        let fields: Vec<_> = obj.collect();
        assert_eq!(fields.len(), 1);

        let field_name = oracle.strings.resolve(fields[0].name).unwrap();
        assert_eq!(field_name, "outer");

        oracle
            .source_map
            .get_bck(&Element::ObjectField(fields[0].id));
        oracle
            .source_map
            .get_bck(&Element::Value(fields[0].id.value_id()));

        // Get nested object from field value
        let inner_obj = match &fields[0].value {
            Value::Object(obj) => obj.clone(),
            other => panic!("expected nested object, got {other:?}"),
        };

        let inner_fields: Vec<_> = inner_obj.collect();
        assert_eq!(inner_fields.len(), 1);

        let inner_field_name = oracle.strings.resolve(inner_fields[0].name).unwrap();
        assert_eq!(inner_field_name, "inner");
        assert_eq!(inner_fields[0].value, Value::Integer(42));

        oracle
            .source_map
            .get_bck(&Element::ObjectField(inner_fields[0].id));
        oracle
            .source_map
            .get_bck(&Element::Value(inner_fields[0].id.value_id()));

        // Verify source map is correct length
        assert_eq!(oracle.source_map.fwd.len(), 5);
        assert_eq!(oracle.source_map.bck.len(), 5);
    }

    #[test]
    fn parse_complex_nested_structure() {
        let text = indoc! {r#"
            name: {
                users: [
                    {
                        name: "alice"
                        age: 30
                    }
                    {
                        name: "bob"
                        age: 25
                    }
                ]
                metadata: {
                    count: 2
                    active: true
                }
            }
        "#};

        let mut diagnostics = vec![];
        let tokens = tokenize(text, &mut diagnostics);
        let res = parse(tokens);

        let mut oracle = Oracle::new_raw(&res.root);

        let value = res.root.api_names().next().unwrap().value().unwrap();
        let id = oracle.parse_value(&value);
        assert_eq!(oracle.reports(), vec![]);

        let obj = match oracle.values.get(id) {
            Value::Object(obj) => obj,
            other => panic!("expected object value, got {other:?}"),
        };
        // Test element is in map. If it isn't get_bck panics.
        oracle.source_map.get_bck(&Element::Value(id));

        let fields: Vec<_> = obj.collect();
        assert_eq!(fields.len(), 2);

        // Check field names (ordering: users, metadata)
        let names: Vec<_> = fields
            .iter()
            .map(|field| oracle.strings.resolve(field.name).unwrap())
            .collect();
        assert_eq!(names, vec!["users", "metadata"]);

        // Verify top-level fields are in source map
        for field in &fields {
            oracle.source_map.get_bck(&Element::ObjectField(field.id));
            oracle
                .source_map
                .get_bck(&Element::Value(field.id.value_id()));
        }

        // Check users array
        let users_arr = match &fields[0].value {
            Value::Array(arr) => arr.clone(),
            other => panic!("expected users array, got {other:?}"),
        };

        let users: Vec<_> = users_arr.map(|it| (it.id, it.value)).collect();
        assert_eq!(users.len(), 2);

        // Verify array elements are in source map
        for (user_id, _) in &users {
            oracle.source_map.get_bck(&Element::Value(*user_id));
        }

        // First user
        let user1_obj = match &users[0].1 {
            Value::Object(obj) => obj.clone(),
            other => panic!("expected user object, got {other:?}"),
        };
        let user1_fields: Vec<_> = user1_obj.collect();
        assert_eq!(user1_fields.len(), 2);

        let user1_names: Vec<_> = user1_fields
            .iter()
            .map(|field| oracle.strings.resolve(field.name).unwrap())
            .collect();
        assert_eq!(user1_names, vec!["name", "age"]);

        // Verify user1 fields are in source map
        for field in &user1_fields {
            oracle.source_map.get_bck(&Element::ObjectField(field.id));
            oracle
                .source_map
                .get_bck(&Element::Value(field.id.value_id()));
        }

        match user1_fields[0].value {
            Value::String(str_id) => {
                assert_eq!(oracle.strings.resolve(str_id).unwrap(), "alice");
            }
            ref other => panic!("expected string, got {other:?}"),
        }
        assert_eq!(user1_fields[1].value, Value::Integer(30));

        // Second user
        let user2_obj = match &users[1].1 {
            Value::Object(obj) => obj.clone(),
            other => panic!("expected user object, got {other:?}"),
        };
        let user2_fields: Vec<_> = user2_obj.collect();
        assert_eq!(user2_fields.len(), 2);

        let user2_names: Vec<_> = user2_fields
            .iter()
            .map(|field| oracle.strings.resolve(field.name).unwrap())
            .collect();
        assert_eq!(user2_names, vec!["name", "age"]);

        // Verify user2 fields are in source map
        for field in &user2_fields {
            oracle.source_map.get_bck(&Element::ObjectField(field.id));
            oracle
                .source_map
                .get_bck(&Element::Value(field.id.value_id()));
        }

        match user2_fields[0].value {
            Value::String(str_id) => {
                assert_eq!(oracle.strings.resolve(str_id).unwrap(), "bob");
            }
            ref other => panic!("expected string, got {other:?}"),
        }
        assert_eq!(user2_fields[1].value, Value::Integer(25));

        // Check metadata object
        let metadata_obj = match &fields[1].value {
            Value::Object(obj) => obj.clone(),
            other => panic!("expected metadata object, got {other:?}"),
        };

        let metadata_fields: Vec<_> = metadata_obj.collect();
        assert_eq!(metadata_fields.len(), 2);

        let metadata_names: Vec<_> = metadata_fields
            .iter()
            .map(|field| oracle.strings.resolve(field.name).unwrap())
            .collect();
        assert_eq!(metadata_names, vec!["count", "active"]);

        // Verify metadata fields are in source map
        for field in &metadata_fields {
            oracle.source_map.get_bck(&Element::ObjectField(field.id));
            oracle
                .source_map
                .get_bck(&Element::Value(field.id.value_id()));
        }

        assert_eq!(metadata_fields[0].value, Value::Integer(2));
        assert_eq!(metadata_fields[1].value, Value::Bool(true));

        // Test source map is correct length
        assert_eq!(oracle.source_map.fwd.len(), 19);
        assert_eq!(oracle.source_map.bck.len(), 19);
    }
}
